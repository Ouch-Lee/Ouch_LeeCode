# Graph Notes

## DFS

首先图最基础的就是深度搜索dfs和广度搜索bfs，dfs有点不到黄河心不死的意思，会一直找下去，直到尽头然后回到到一个节点，所以dfs和回溯算法的原理一模一样，只不过之前的二叉树变成了图，下面给出两者的伪代码框架

dfs

```c++
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```





### 所有可达路径

最基础的一道DFS问题，从节点1开始，一路回溯下去



### 岛屿问题一

这道题的思路是这样的，每当你碰到一个新的大陆，那么你可以计数器+1，暴力的方法就是把每个大陆都判断一遍是不是不连通的陆地，用dfs的方法，可以一一个节点作为索引的初始点，然后把所有和他连起来的节点都标记一下，这样，后面再遍历的时候就可以直接跳过；





## BFS

广度优先，就是一层一层的来，对应二叉树的搜索就是层序遍历，在图里面就是以一个节点为中心，然后把与它连接的节点都加进来，然后再下一层，把刚才加进来的节点相连的节点都加进来；



### 字符串接龙

这个问题是查找从begin字符串开始，最少多少步能够变道end字符串，且每次只能变一个字符串，这题就很适合用BFS，因为BFS就像水波一样散开，如果碰到到了目标（end）那么它肯定是最短路径；相反DFS可能绕路；

思路大概是这样的，先构建一个map，用来记录list里面字符串到起点的长度（同时也可以区分字符串是否被访问过）；





## 最小生成树

最小生成树要解决的问题，通常是在一个无向有权图中生成一个最短的路径，因为这个路径不会形成环，像一颗树，所以被称为最小生成树，为了解决这个问题，通常有如下两种方法

### Prim

该方法的主要原理是，依次添加最短路径，如何理解呢？假如一开始所有的节点都没有被加进来，那么随便找一个节点，通常是node1，这个过程可以想象成node1被点亮了，其他的都是暗的，接下来我们的目的就是用**最短**的路径把其它的通通点亮；下一步就是找和node1相连最短的node，并加进来，加进来以后，点亮部分就有两个node，下一步就是找和【点亮部分】相距最近的node，依次点亮全部即可；上述过程如何用代码实现呢？

* 选距离生成树最近节点
* 最近节点加入生成树
* 更新非生成树节点到生成树的距离



### Kruskal

上面方法我愿称之加点发，而这个则是加边法；首先kruskal法会把边按权重进行排序，优先添加权重最小，且加入之后不会形成环的，也就是之前说的并查集；上述方法尝试使用代码实现





## 最短路径 

### Dijkstra

这个算法主要用于解决最短路径的问题，其实现的流程和Prim算法非常的像

* 选择源点到哪个节点近且该节点未被访问过
* 访问过做标记
* 非访问节点到源点的距离（更新minDist数组

其中minDist数组的作用是存放第i个节点到源点的距离，这个距离在迭代的过程中会动态改变

如何确定【源点到哪个节点近】呢？首先有一步可以到的，和两步可以到的，等等



### Bellman_ford

这个算法是对dijkstra算法的补充，可以解决权边为负的情况，至于dijkstra为什么不能处理负（我这里还没有搞懂），其大致思路是对于n个节点，进行n-1次松弛，如何理解这个松弛呢？以一个节点B来说，就是求出到节点B的最小权重（这个权重有两种状态，之前累计的minDist[B] 和 节点A新接过来的一条路径， minDist[A] + value）

```
minDist[B] = min(minDist[A] + value, minDist[B])
```

每一次松弛都要选中一个节点作为对象，然后把输入的边都做更新对象

```
for (int)
```



为了求得最小值，需要对所有的边进行【松弛一次】

### Floyd

这个算法算是dijstra的升级版，因为它求的是任意两个节点之间的最短路径（相当于两层for循环做dijstra，当然复杂度不是这样），其实现的核心思路是【动态规划】，实现的原理如下：

使用两个矩阵进行迭代：

* mat1^{n}(i)(j)  是以第n个节点作为中间节点时，节点i到节点j的最短路径
* mat2^{n}(i)(j)  是目前节点i到节点j的最短距离（也是我们要的结果）

当然上面两个矩阵可以合并成一个三维矩阵，因为矩阵1矩阵2之间是耦合的，同时两者都是动态变换的；所有可以构建一个三维矩阵作为之前的动态迭代矩阵dp，要做的就是从第一个二维矩阵一层一层的迭代到k层；下面是动规五部曲：

* 定义dp，这里换个叫法叫 grid [ i] [j] [k]，其含义是从节点i到节点j，以[1...k]集合中任意一个节点作为中间点时的最短路径
* 递归公式，grid [ i] [j] [k] 需要从 grid [ i] [j] [0]=> grid [ i] [j] [1] => ......  => grid [ i] [j] [k] 这个过程慢慢推导过来，因此 grid [ i] [j] [k] 实际上取决于 grid [ i] [j] [k-1]
  * 当这个最短路径中间点是k时，那么 grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]
  * 当它不是k时，grid[i][j][k] = grid[i][j][k - 1]
* 初始化，节点0是没有含义的，
* 遍历顺序：最外层的遍历肯定是 k ，直接把 grid [i] [j] 这个二维数组当成一个元素，每一次k++都是更新这个元素，内层则无所谓
* 推导



