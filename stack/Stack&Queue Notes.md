# Stack&Queue Notes

## 基础知识

常见API：

### C++ STL `stack` 常用 API

| **函数**       | **功能描述**               | **用法示例**                      |
| -------------- | -------------------------- | --------------------------------- |
| `stack()`      | 构造一个空栈               | `std::stack<int> s;`              |
| `push(value)`  | 向栈顶添加一个元素         | `s.push(10);`                     |
| `pop()`        | 移除栈顶元素（不返回值）   | `s.pop();`                        |
| `top()`        | 返回栈顶元素（不移除）     | `int topElement = s.top();`       |
| `empty()`      | 检查栈是否为空，返回布尔值 | `bool isEmpty = s.empty();`       |
| `size()`       | 返回栈中元素的数量         | `size_t count = s.size();`        |
| `swap(stack&)` | 交换两个栈的内容           | `std::stack<int> s2; s.swap(s2);` |



| **函数**       | **功能描述**                   | **用法示例**                      |
| -------------- | ------------------------------ | --------------------------------- |
| `queue()`      | 构造一个空队列                 | `std::queue<int> q;`              |
| `push(value)`  | 向队列末尾添加一个元素         | `q.push(10);`                     |
| `emplace(...)` | 在队列末尾构造一个元素         | `q.emplace(20);`                  |
| `pop()`        | 移除队列前端的元素（不返回值） | `q.pop();`                        |
| `front()`      | 返回队列前端的元素（不移除）   | `int frontElement = q.front();`   |
| `back()`       | 返回队列后端的元素（不移除）   | `int backElement = q.back();`     |
| `empty()`      | 检查队列是否为空，返回布尔值   | `bool isEmpty = q.empty();`       |
| `size()`       | 返回队列中元素的数量           | `size_t count = q.size();`        |
| `swap(queue&)` | 交换两个队列的内容             | `std::queue<int> q2; q.swap(q2);` |

##  题目笔记



### 4-有效括号

就是说，要左右括号一一对应，这个很容易就能想到实用stack，先进后出，判断好逻辑关系即可，但是官方给的思路很有意思：

如果出现左括号，就push对应的右括号，如何是右括号且等于目前顶端的右括号，就弹出去就行了





### 5-删除重复元素

因为是在stack这一节，所以很容易就能想到实用stack实现这个功能，就是当放入stack时候，如果top和目前放的相同，说明两个连续的元素相同，直接不放进去，然后把top元素弹出就好了（确实很妙）

需要注意的是，此时存放元素的结构是stack，题目需要返回的是string，所以还要做一次数据转换





### 6-逆波兰求值

如果不是符号，就把数字加入stack里面，如果是符号，就取出最上面两个两个值，（值得注意的是，这里不要用int，而是用long long，）因为只有四种运算符号，因此可以用switch执行不同计算。



### 7-滑动窗口最大值

很妙的是，自己构建一个单调队列，这个队列只收集比尾部更大的值，而且如何收入的值如果比尾部大，就一直排除小的；pop时，只有要pop的值等于头部值才pop，因为有些小的值没有机会到头部，因此可以直接跳过；

