# BinaryTree_Notes

## 遍历方法

### 递归实现遍历

遍历主要分为三种：

* 前序遍历（中左右）
* 中序遍历（左中右）
* 后序遍历（左右中）

具体例子看这张图

![](./二叉树遍历.png)

为了实现上述三种遍历方法，可以通过两种思路来实现

```cpp
void preTravel(TreeNode* root, vector<int> * result)
    {
        if(root == nullptr) return;
        result->push_back(root->val);
        preTravel(root->left, result);
        preTravel(root->right, result);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        preTravel(root, &result);
        return result;
    }
```

```
void inoderTravel(TreeNode * root, vector<int> &vec)
    {
        if(root == nullptr) return;
        inoderTravel(root->left, vec);
        vec.push_back(root->val);
        inoderTravel(root->right, vec);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        inoderTravel(root, result);
        return result;
    }
```



### 层序遍历

层序遍历比较直观，就是一层一层的遍历下去，因为符合排队的思维，所以可以使用一个队列结构，把最前面的节点放进来，然后取出，再把它的两个子节点放进来，一直取到队列空的，就把树遍历完了；需要注意的是【每一层开始时，需要计算队列的尺寸，然后后续无论是添加到数组还是队列添加左右子节点，都只需要执行size次，】



### 迭代实现





## 题目笔记



### 中后序遍历构造二叉树

这题需要知道从中序，后序中构造二叉树的核心原理：**后序数组最后一个树即为对应树的跟节点，而在中序数组中，根节点对应的值又把中序数组分为两半**

因此，可以借用递归的方法，重构二叉树，伪代码如下

```
1. 从后序数组post中提取最后一个值fianl
2. 在中序数组in 中找到final对应的位置index
3. 中序数组以index为界限，将数组分为两个左右子数组（需要注意边界问题）
4. 保持数量相同的情况下，把post分为两半
5. 进行递归
```

需要注意特殊情况：

1. 当子数组为空的时候，就不能进行访问了，否则会出现空指针
2. 当后序长度为1的时候，说明已经只剩根节点了



### 最大二叉树

根据题目的要求，每一次只需要找出最大值，然后以最大值将数组分为两部分就可以了，和上面一题极为相似，很简单，直接给出伪代码：

```
1. 找到最大值，以及对应的index（这里问了gpt，用max_element函数，返回一个auto类型数据，并对其解引用）
2. 划分左右子数组
3. 递归
```


### 合并二叉树

感觉可以采用前序遍历，思路伪代码：

```
1. 前序遍历的过程是，先求值，再左，再右
2. 因此第一步是求值，分四种情况讨论
3. 向左递归，但是需要注意，如果有空：如果tree1是空就 return tree2; 反之，
4.同理于向右
```

笔记，代码是写出来了没错，但是对比Carl的代码，首先在逻辑清晰性和简洁性上完全比不过，很简单的判断，我需要四条if else，但是人家很简单就能写出来；



### 二叉搜索树中的搜索

目标是搜索出树中的一个值，然后返回它的子树，感觉也不难，用前序递归的方法，如果找到了val，就返回？找不到就找子树？

没审题【二叉搜索树】：

二叉搜索树（BST，Binary Search Tree）是一种特殊的二叉树，满足以下性质：

1. 若左子树不为空，则左子树上所有节点的值都小于根节点的值。
2. 若右子树不为空，则右子树上所有节点的值都大于根节点的值。
3. 左右子树本身也必须是二叉搜索树。
4. 空树也是一棵二叉搜索树。

看清题目也不是很难，甚至更简单？



### 验证二叉搜索树

二叉搜索树，是要左子树的所有值（而不是left->val）都比跟节点小，同理于右子树

如果把验证二叉树按中序遍历走一遍，那么得到的中序数组必然是一个递增的数组，判断一下这个数组是不是递增的就可以了



### 二叉搜索树abs min

利用好二叉搜索树性质，把它中序遍历一遍后，得到单调的数组，只需要求相邻两个值的最小值就可以了

carl给出了一个不需要额外数组的方法，核心是用一个pre记录上一个node





### 二叉树最近公共祖先

找公共祖先，所以理所当然是从后面向前进行检索，也即后序遍历；遍历函数的返回值不能设成简单的bool，这样遍历的过程不方便传递结构，核心思路伪代码如下

```
1. 如果是空节点，肯定返回null
2. 向左遍历
3. 向右遍历
4. 判断的逻辑
重点是判断的逻辑，如果cur等于taskVal，那么肯定要返回cur的，重点是，如果cur的父节点的另一侧返回的为null（也即另一侧没有目标值），这个时候应该要返回cur，而不能返回当前节点，这样判断结束的逻辑仍然可以是当左右子节点不为空；另外，就算找到了公共祖先，这个迭代亦不会停下去，这个时候需要一个判断逻辑将结果传递下去

	
```



### 搜索树最近公共祖先

搜索树的优点是，数值之间存在一点关系的，如果一个节点是目标节点的公共祖先，那么必然满足一个大于小的，小于大的，不满足的就可以直接pass，根据这个逻辑可以简化很多遍历

### 修剪BST

目标是除掉不在给定范围内的节点，实际上就是进阶版的删除节点

首先确定递归的方法可以解决这个问题，使用前序遍历，碰到不在区间内的node，去掉并保证正确重构即可，至于怎么重构后面讨论

递归三部曲：

* 确定返回值：理论上void即可，但是有TreeNode做返回值更方便？（其实没太理解，问了gpt，gpt给出的解答是：当你需要修改树的结构的时候，需要返回TreeNode* 这个可以使用到其他的数据结构，当你需要在迭代的过程中不断修改该数据的结构时，需要return，反而只需要访问，就可以void，这个和普通的函数原理其实一样）
* 终止条件：遇到空节点就return nullptr
* 单层循环逻辑：如果cur val在范围内就直接下一层，如果不在，那么就是重点

伪代码：

```
1. 如果这个节点是子叶点，那么可以直接删了
2. else if val大于上边界
    把left接上来，继续遍历左子树
3. else if val 小于下边界
    把rihgt接上来，继续遍历又子树
```

关于要不要删掉cur有问题，不删会出现访问空指针，具体的看这个例子[1,null,2] ,(2,4)



### 有序数组toBST

核心是寻找数组的中间元素，将其设为头节点，然后以该节点为分界线分为左右两个数组，之后进行递归；

关于寻找中间元素，如果当前是奇数长度，就是最中间的元素，如果是偶数长度，应该左右都可以，最好把小的数定位头部；

```cpp
if (vec.size() % 2 == 0)
{
    int mid = n /2 - 1;
    int midVal = vec[mid];
    
} else
{
    int mid = n/2;
    int midVal = vec[mid];
}
cur->val = midVal;
vecLeft = vec[bigen(), begin() + mid];
vecRight = vec[begin() + mid + 1, end()];

TreeNode* leftNode = Func(cur, vecLeft);


```

迭代函数设计

* 返回值，因为要构建一个树，要涉及修改节点，因此肯定是返回TreeNode* 
* 迭代终止条件，如果vec长度为1，mid=0，mid+1会越界，所以长度为1的时候就要return了
* 单层迭代逻辑：在上面



写了那么一大堆，别人用指针的方法两下就搞定了，所以说 【**当有二分找的时候你第一个就应该想到二分法**】；就是需要注意左右开闭的问题



### BSTto累加树

这个我熟，只需要反着中序遍历，然后把count累积起来赋值给当前node即可，需要注意的是，count应该创建为全局变量，static的局部变量是不行的，应该需要多次调用这个函数
