# DP Notes

根据之前动态规划理论的学习，DP有三个很重要的概念：

* 状态：每一次迭代对应一个新的stage
* 决策变量：
* 状态变量：

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定动态数组DP的含义

2. 确定递推公式

3. 确定初始值

4. 确定遍历的顺序

5. 推导出来dp

   

## 斐波那契数列

这题其实最开始想到的是递归，但是发现递归所需的内存非常大；而这题使用动态规划就非常合适，之前一直以为动态规划是从后往前递归，但是实际上还是前面的数据得到后面的数据，只不过可以从后往前想：比如我想知道n，它可能可以有n-1得到，而想要n-1又可以由n-2得到，慢慢推导1，也就是：【**如果我们知道连接的关系（递推公式）就可以从初始值到我们想要的值**】；

回到斐波那契数列，递推公式已经给出了： $F(n) = F(n-1) + F(n-2)$

1. DP[i] 就是第i个数的值(dp[n-1])
2. 上面给了

2. DP[1] = 1, DP[2] = 1;
3.  for (int i = 3; i < n; n++) { dp[i] = dp[i-1] + dp[i-2] };
4. return dp[n-1];



## 爬楼梯

1. 同样dp[i]定义为第i个楼梯有几种方法，长度定义为dp[n-1]
2. 地推公式和斐波那契数列一模一样
3. dp[1] = 1; dp[2] = 2;
4. 一样的



### 最小花费爬楼梯

稍微比爬楼梯难一点；在于递推公式不是简单的 $F(n) = F(n-1) + F(n-2)$；而是 
$$
F(n) = min{F(n-1)+cos[n-2], F[n-2] + cost[n-1]}
$$

3. F[0] = 0, F[1] = 0,  

   

## 不同路径







## 背包问题





### 一维数组

如果使用一维素组，d[j]就是表示背包空间为j时能够获取的最大利益

那么递推公式： dp[j] = max(dp[j], dp[j-weight[i]] + value[i]); 这里会用参数i把所有的物品都遍历，得到每种物体装进来的最大利益；

初始值：dp[0] = 0;  for (int j = weight[0]; j <= n; j++) dp[j] = value[0];

