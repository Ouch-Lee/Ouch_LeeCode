# 回溯算法

回溯算法是一种系统地搜索所有可能解的方法，通常用于解决组合、排列、分割等问题【通常只能使用for暴力遍历的问题】。它通过逐步构建候选解，一旦发现当前路径不符合条件或不可能有解，就立即回溯，尝试其他可能性。

回溯和递归的逻辑有点像，目前看来回溯里面包含了递归。回溯也可以做三部曲：

* 确定返回值和传参

* 回溯停止逻辑

  ```
  if (终止条件) {
          存放结果;
          return;
      }
  ```

* 单层回溯逻辑：

  ```
  for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
      处理节点;
      backtracking(路径，选择列表); // 递归
      回溯，撤销处理结果
  }
  ```



### 组合总和3



* 首先确定终止条件，就是path长度为3且和为n
* 返回参数，理论上来说用void就行，传参，n和k



### 电话号码组合

重点有两个：

* 找到映射关系，最先想到的是使用map，将数字映射到对应的string，官方给出了一个简单的方法，直接构建一个string的数组，下标可以对应num
* 什么

三部曲

* 传参和返回

* 终止条件：明显终止条件就是path的长度等于给定数字的个数，也即 path.size() == n; 但是官方没有直接使用path.size() ，而是用一个参数index，表示path已经放了几个数；这样做的好处是，能够获取当前对应的按键，通过映射得到对应的string，作为单层回溯的基础

* 单层回溯逻辑：

  每一层对应一个按键数字，每个数字有3/4个字母，需要把这些字母都遍历一遍



### 组合总和

关于回溯和递归的return，我感觉我还是没有完全明白，以递归来说，return了，代码就会回到进入这一层递归的位置，然后进行执行上一层没有执行完的代码。那回溯应该也一样，如果return会回到上一层并继续

* 仍然可以采用两个全局变量，所以返回类型void就好了，传参需要给的两个参数（candidate和target，以及单层遍历开始的位置start）
* 终止条件：path之和等于或大于target，等于就把path加进result然后return，大于就直接结束（关于这个结束，可以做一些剪枝优化，就是把大于最后一个值的数都跳过<但是怎么实现呢>）
* 单层递归：单层就是把所有candidate里面的数都遍历一遍，因为可以重复使用，所以层数并不像之前那样固定，而是根据终止条件结束



### 数组总和2

这题不一样的地方在于，有重复的数组，但是不可以一直拿一样的，

* 返回类型仍然是void，传参除了两个默认的，还需要start用于往下回溯，以及sum用来回溯时判断是否停止；为了避免重复的数字在同一层内再来一遍，还需要添加一个use数组，判断这个数字有没有被用过

* 终止条件：等于就return

* 单层递归：

  如果没有剪枝和优化操作，其实可以和之前一样，因此具体要做的两件事是：

  * 第一，如果当前的sum+candidate[i] > target了，那么就直接break，后面都不要管
  * 第二，如果当前的值[i] 等于上一个，那么可以直接跳过



### 回文串分割

回文串分割就是要把一个字符串s分成都是符合回文串的子串，既然涉及到子集的问题，那么就可以使用回溯，而横向的回溯就是 逐步增加个数，例如 s = "abcd" ，那么横向子集就是 "a", "ab", "abc" "abcd"，而纵向递归就是在剩余的子集中重复上面横向的过程，一直到底部了就回溯

所有几件比较重要的事情

* 递归终止条件：深度（通常用startIndex表示）到了最后一个数

* 单层递归：也就是横向，从startIndex到最后一个，如果从start到i 这一段子字符串满足回文串，那么把它加进path里面，然后继续递归

  ```cpp
  for (int i = startIndex; i < s.size(); i++)
  {
  	if (isValid(s, startIndex, i))
  	{
  		string subStr = s.substr(startIndex, i - startIndex + 1)
  		path.push_back(subStr);
  	} else  // 不是回文的话，就直接跳过，因为后面可能还有所以不能break
  	{
  		continue;
  	}
  	backTracking();
  	path.pop_back();
  }
  ```

* 参数，仍然是采用void，必须的参数s，以及辅助参数startIndex



### IP分割

IP分割也是把一个字符串s分成符合IP标准的子集，所以思路上和回文串分割很像，这里直接给出三件套

* 终止条件：出现四个子串，用一个count检测已有的IP串，如果count == 3，且最后一串符合要求，那么就把当前s扔进result

* 单层递归：横向递归也是把startIndex指针一个个往右移动

  ```
  for (int i = startIndex; i < s.size(); i++)
  {
  	if (isValid())
  	{
  		// 在i+1的位置加一个‘.’
  		count++；
  		然后backTrack
  		回来后删掉 '.'
  		count--
  	} else 如果不符合要求，那后面的都不用看了
  }
  ```

* 传参也一样

* 很重要的是判断一段字符串是不是满足IP条件

  * 开头不能是0
  * 中间不能出现0-9以外的符号
  * 数字超过255就不行



### 子集

前面讲了组合、分割问题，现在需要总结一下这些问题之间的区别了，给定一个集合：

* 组合：从这个集合中挑出几个数进行组合，思路就是从左到右，从上到下一个一个取

  ![](https://file.kamacoder.com/pics/20201123195223940.png)

* 分割：也是要按顺序取，但是横向并不是一个个取，而且逐个递增，而且取的过程中终止条件不一样，同时还需要加一些判断这个元素能不能加进来

  ![](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

* 子集：不同于组合，一定需要达到规定的组合数目才可以，集合需要把所有的过程组合收集起来，也就是说组合关注的是**最后一层满足终止条件**的叶子，而子集就是把**所有叶子**都收集起来

![](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

有了这个基础的概念以后，我们再来看子集问题：我们需要列出所有回溯过程中的叶子，横向、纵向都要达到最大尺寸。

* 递归函数参数：基本不变

* 终止条件：指针到了最大值；需要注意的是，每次递归都要先把path加进result，这样才能收集所有叶子

* 单层递归：

  ```
  for (int i = start; i < size; i++)
  {
  	三件套
  }
  ```

  

### 子集2

不同于上面的就是，集合中有重复的元素，但是子集不能出现重复的，那么和之前重复处理的思路就一样了，需要额外引入一个bool类型的 used 数组来记录前面的数是否出现过；其它就没有什么变换



### 递增子序列

这题和上面不一样的是，上面进行回溯前可以先对集合sort一样，这样方便处理重复的元素，但是这题不能sort，



