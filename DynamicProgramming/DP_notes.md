# DP Notes

根据之前动态规划理论的学习，DP有三个很重要的概念：

* 状态：每一次迭代对应一个新的stage
* 决策变量：
* 状态变量：

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定动态数组DP的含义

2. 确定递推公式

3. 确定初始值

4. 确定遍历的顺序

5. 推导出来dp

   

## 斐波那契数列

这题其实最开始想到的是递归，但是发现递归所需的内存非常大；而这题使用动态规划就非常合适，之前一直以为动态规划是从后往前递归，但是实际上还是前面的数据得到后面的数据，只不过可以从后往前想：比如我想知道n，它可能可以有n-1得到，而想要n-1又可以由n-2得到，慢慢推导1，也就是：【**如果我们知道连接的关系（递推公式）就可以从初始值到我们想要的值**】；

回到斐波那契数列，递推公式已经给出了： $F(n) = F(n-1) + F(n-2)$

1. DP[i] 就是第i个数的值(dp[n-1])
2. 上面给了

2. DP[1] = 1, DP[2] = 1;
3.  for (int i = 3; i < n; n++) { dp[i] = dp[i-1] + dp[i-2] };
4. return dp[n-1];



## 爬楼梯

1. 同样dp[i]定义为第i个楼梯有几种方法，长度定义为dp[n-1]
2. 地推公式和斐波那契数列一模一样
3. dp[1] = 1; dp[2] = 2;
4. 一样的



### 最小花费爬楼梯

稍微比爬楼梯难一点；在于递推公式不是简单的 $F(n) = F(n-1) + F(n-2)$；而是 
$$
F(n) = min{F(n-1)+cos[n-2], F[n-2] + cost[n-1]}
$$

3. F[0] = 0, F[1] = 0,  

   

## 不同路径







## 背包问题

### 01背包

01背包是较为基础的题目，通常题目的描述是会告诉你背包的容量是n，以及存在m件物体，每件物体有它的重量和价值，分别在数组 weight[m] 和 value[m]中，目标是求解容量为n的背包能够携带的最大价值，这样的问题通常可以使用二位数组或者一维数组来解决：

* 一维数组

如果使用一维素组，d[j]就是表示背包空间为j时能够获取的最大利益

那么递推公式： dp[j] = max(dp[j], dp[j-weight[i]] + value[i]); 这里会用参数i把所有的物品都遍历，得到每种物体装进来的最大利益；

初始值：dp[0] = 0;  for (int j = weight[0]; j <= n; j++) dp[j] = value[0];

这里有两层for循环，一层是遍历背包的容量，一层是遍历物体；什么时候哪个在外面了，这里面有一定的考究：


1. **01背包（物品不可重复使用）**
   - **一维数组实现时**：必须**先遍历物品，再倒序遍历背包容量**（从大到小）。
     原因：倒序确保每个物品仅被计算一次。若正序遍历，`dp[j - weight[i]]`会被当前物品多次更新，导致重复计算

2. **完全背包（物品可重复使用）**
   - **一维数组实现时**：需**正序遍历背包容量**（从小到大），但遍历顺序可灵活调整：
     - 若求**组合数**：外层遍历物品，内层遍历背包容量（避免顺序差异）
     - 若求**排列数**：外层遍历背包容量，内层遍历物品（允许顺序差异）

所以以后做提前，先想清楚是01背包还是完全背包（只用看元素能不能重复取就完事了）；然后再来判断是求组合还是排列问题，两者的区别是相同的集合如果里面排序不一样，组合算一种，排列算多种，组合问题



### 分割等和子集

也就是，看子集组合起来能不能刚好等于 sum/2 ；那么就是背包的容量为 sum/2， 每个数的价值和重量都是它本身



### 最后一块石头的重量

这题是尽可能的往 sum/2 上面靠，我们可以建立一个容量为 sum/2 的背包模型，然后看一下最多能够装满多少。这题就成了典型的01背包问题



### 目标和

这题做之前首先需要稍微推导一下，假如给定数据的和为sum，目标数字为target，我假设sum中有left的数用于当正数，剩余 sum - left 的数作负数，那么有如下关系：
$$
left - (sum - left) = target \\
left = (sum + target) / 2
$$
那么我们可以构建一个容量为 left 的01背包，最终看一下有几种情况能够构成 left



### 一个零



### 完全背包





