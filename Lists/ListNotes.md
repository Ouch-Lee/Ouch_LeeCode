# List

链表的核心为val和next，其中val是当前链表储存的值，而next是一个List类型的指针，指向下一个链表节点的地址。链表与之前数组不同的点在于，数组的地址是连续的，而链表的相邻元素地址不连续，而是用一个next的指针，指向下一个地址的位置，list的实现也非常简单，

```cpp
typedef Struct 
{
	int val;
	ListNode * next;
    ListNode(int x) : val(x), next(nullptr);
} ListNode;
```



## 链表类型

* 单向链表：上面说的就是
* 双向链表：除了next，还有一个last指向上一个
* 环形链表：最后一个节点指向第一个节点的地址
* 



## 链表删除元素

由于链表的地址不连续性，所以链表可以做到数组做不到的删除元素操作，原理如下：找到对应的元素tarNode，将tarNode的上一个节点指向next；因此需要保存上一个节点信息，同时要避免空指针，也即next是空的情况





### 构建自己的List





## 翻转链表

链表的题目都不算很难，但是如果不把问题想清楚，就即花时间，还会存在一些bug；翻转链表这题，就是需要每更新cur时候，需要把cur从下一个指向上一个；然后cur的下一个指向cur

关于迭代终止条件，很多时候不确定是cur还是cur->next；这个时候考虑一下特殊情况时会不会出现空指针即可，像这里因为最后返回的是pre，所有cur的next可以是空指针

我一直有一个误区就是，没有讲dummy节点设置为Null，同时dummy节点不应该和head连接起来，这个是和之前不太一样的地方

```
while (cur)
{

}
```

## 两两交换

两两交换需要一对Node刷新才需要进行操作，那么首先我们可以把循环判断条件设为

```
cur->next && cur->next->next
```

发现自己在做List的题目时很容易出席那【运行时间超时】的报错；是因为在转换节点关系的时候很容易【形成环】，导致内部打结



## 删除倒数N个

这个我第二遍做想得是用双指针法，我觉得没什么问题

首先确定fast到哪个位置slow开始走，因为fast走到最后面的时候，slow应该在倒数第n+1个节点；因此，可以先让fast走n步，然后slow和fast一起向右移动
